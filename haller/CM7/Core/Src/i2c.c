#include "../Inc/i2c.h"

#define I2C_FREQ 0x307075B1U 										//100kHz generated by STM32CubeMX tool
#define I2C_CR2_SADD7BIT_Pos 		(1U) 							//Processor header file has this option only for 10-bit addressing mode
#define I2C_WR_REG_SIZE 			(8U)
#define I2C_WR_REG_MASK				(0xFF)

typedef enum Mode {WRITE, READ} Mode;

void I2C1_Master_Init(void){
	I2C1->CR1 &= ~I2C_CR1_PE; 										//Ensure software reset for I2C1
	RCC->APB1LENR |= RCC_APB1LENR_I2C1EN; 							//Peripheral clock enable for I2C1
	RCC->AHB4ENR |= RCC_AHB4ENR_GPIOBEN; 							//GPIOB clock enable
	GPIOB->MODER |= (GPIO_MODER_MODE6_1 | GPIO_MODER_MODE7_1); 		//Enable alternate function for PB6 and PB7
	GPIOB->OTYPER |= (GPIO_OTYPER_OT6 | GPIO_OTYPER_OT7); 			//Configure PB6 and PB7 to work as open-drain
	GPIOB->OSPEEDR |= (GPIO_OSPEEDR_OSPEED6 | GPIO_OSPEEDR_OSPEED7);//Set output speed of PB6 and PB7 as very high
	//GPIOB->PUPDR |= (GPIO_PUPDR_PUPD6_0 | GPIO_PUPDR_PUPD7_0);	//Enable pull-up resistors for PB6 and PB7 // is this done externally?
	GPIOB->AFR[0] |= (GPIO_AFRL_AFSEL6_2 | GPIO_AFRL_AFSEL7_2); 	//Set alternate function as I2C1 for pins PB6 and PB7 (SCL and SDA)
	I2C1->TIMINGR |= I2C_FREQ; 										//Set I2C1 speed frequency
	I2C1->CR1 |= I2C_CR1_PE;	 									//Enable I2C1

	I2C1->CR2 |= I2C_CR2_AUTOEND;									//Enable auto-end feature
	I2C1->CR2 &= ~I2C_CR2_ADD10;									//7-bit addressing mode
}

void I2C1_Start(Mode mode, uint8_t addr, uint8_t size){
	I2C1->CR2 &= ~(I2C_CR2_SADD); 									//Clear address. //Disc. CR2 bit0 is don't care
	I2C1->CR2 |= addr<<I2C_CR2_SADD7BIT_Pos;						//Set slave address
	I2C1->CR2 |= size<<I2C_CR2_NBYTES_Pos;							//Number of bytes to read/write
	if(mode == WRITE) I2C1->CR2 &= ~(I2C_CR2_RD_WRN);				//Write Request
	else if (mode == READ) I2C1->CR2 |= I2C_CR2_RD_WRN;				//Read request
	I2C1->CR2 |= I2C_CR2_START;										//Start communication
}

void I2C1_Master_Write(uint8_t addr, uint32_t *msg, uint8_t size){
	I2C1_Start(WRITE, addr, size);
	for(uint8_t stage=0;stage<size;stage++){						//Writing remaining bytes
		while( !(I2C1->ISR & (I2C_ISR_TXE) ) );
		I2C1->TXDR = ((*msg)>>(stage*I2C_WR_REG_SIZE )) & I2C_WR_REG_MASK;
	}
	//Automatic end mode closes transmission after NBYTES are sent
}

void I2C1_Master_Read(uint8_t addr, uint32_t *buf, uint8_t size){
	I2C1_Start(READ, addr, size);
	for(uint8_t stage=0;stage<size;stage++){						//Reading remaining bytes
		while( !(I2C1->ISR & (I2C_ISR_RXNE) ) );
		*buf |= (I2C1->TXDR)<<(stage*I2C_WR_REG_SIZE );
	}
	//Automatic end mode closes transmission after NBYTES are read
}

void I2C1_GC(uint32_t *data, uint8_t size){
	I2C1_Master_Write(0x00, data, size);							//I2C1 general call function
}



